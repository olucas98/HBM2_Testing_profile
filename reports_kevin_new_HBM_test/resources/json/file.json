[{"path":"/opt/intel/oneapi/dev-utilities/2021.10.0/include/dpc_common.hpp", "name":"dpc_common.hpp", "has_active_debug_locs":false, "absName":"/opt/intel/oneapi/dev-utilities/2021.10.0/include/dpc_common.hpp", "content":"// Copyright (C) 2020 Intel Corporation\u000A// SPDX-License-Identifier: MIT\u000A\u000A#ifndef _DP_HPP\u000A#define _DP_HPP\u000A\u000A#include <stdlib.h>\u000A#include <exception>\u000A\u000A#include <sycl/sycl.hpp>\u000A\u000Anamespace dpc_common {\u000A// This exception handler will catch async exceptions\u000Astatic auto exception_handler = [](sycl::exception_list eList) {\u000A  for (std::exception_ptr const &e : eList) {\u000A    try {\u000A      std::rethrow_exception(e);\u000A    } catch (std::exception const &e) {\u000A#if _DEBUG\u000A      std::cout << \"Failure\" << std::endl;\u000A#endif\u000A      std::terminate();\u000A    }\u000A  }\u000A};\u000A\u000A// The TimeInterval is a simple RAII class.\u000A// Construct the timer at the point you want to start timing.\u000A// Use the Elapsed() method to return time since construction.\u000A\u000Aclass TimeInterval {\u000A public:\u000A  TimeInterval() : start_(std::chrono::steady_clock::now()) {}\u000A\u000A  double Elapsed() {\u000A    auto now = std::chrono::steady_clock::now();\u000A    return std::chrono::duration_cast<Duration>(now - start_).count();\u000A  }\u000A\u000A private:\u000A  using Duration = std::chrono::duration<double>;\u000A  std::chrono::steady_clock::time_point start_;\u000A};\u000A\u000A};  // namespace dpc_common\u000A\u000A#endif\u000A"}, {"path":"/ihome/ageorge/opl1/Documents/k_mers/kmer_testing/src/kevin_new_HBM_test.cpp", "name":"kevin_new_HBM_test.cpp", "has_active_debug_locs":false, "absName":"/ihome/ageorge/opl1/Documents/k_mers/kmer_testing/src/kevin_new_HBM_test.cpp", "content":"#include <CL/sycl.hpp>\u000A#include <algorithm>\u000A#include <chrono>\u000A#include <cmath>\u000A#include <iostream>\u000A#include <random>\u000A#include <string>\u000A#include <sycl/ext/intel/ac_types/ac_int.hpp>\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A\u000Ausing namespace cl::sycl;\u000A\u000A#include \"dpc_common.hpp\"\u000A#include \"pipe_utils.hpp\"\u000A#include \"unrolled_loop.hpp\"\u000A\u000A// total number of test data point\u000A// #define kDataCount 0x1800000\u000A// number of banks in use\u000A#define BANKS 32\u000A#define NSEC_IN_SEC 1000000000.0\u000A\u000Ausing DataType = ac_int<256, false>;\u000A\u000Ausing data_pipes = fpga_tools::PipeArray<class some_pipes, DataType, 32, BANKS>;\u000A\u000Aclass ProducerKernel;\u000Atemplate <int idx>\u000Aclass ConsumerKernel;\u000A\u000Aint main(int argc, char *argv[]) {\u000A#if FPGA_SIMULATOR\u000A  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\u000A#elif FPGA_HARDWARE\u000A  auto selector = sycl::ext::intel::fpga_selector_v;\u000A#else  // #if FPGA_EMULATOR\u000A  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\u000A#endif\u000A  try {\u000A    cl::sycl::property_list propList{\u000A        cl::sycl::property::queue::enable_profiling()};\u000A    sycl::queue q(selector, dpc_common::exception_handler, propList);\u000A    std::cout << \"Running on device: \"\u000A              << q.get_device().get_info<sycl::info::device::name>() << \"\\n\";\u000A\t\u000A\tconst uint32_t kDataCount = 0xF00000;\u000A    //const uint32_t kDataCount = 0x1800000;\u000A\u000A    DataType *out_matrix[BANKS];\u000A\u000A    for (int j = 0; j < BANKS; j++) {\u000A      out_matrix[j] =\u000A          (DataType *)aligned_alloc(64, sizeof(DataType) * kDataCount);\u000A    }\u000A\u000A    // std::vector<std::vector<DataType>> out_matrix(BANKS,\u000A    // std::vector<DataType>(kDataCount));\u000A\u000A    sycl::range<1> kData_range{(size_t)kDataCount};\u000A\u000A    {\u000A      std::vector<sycl::buffer<DataType, 1> *> bank_bufs;\u000A      fpga_tools::UnrolledLoop<BANKS>([&](auto i) {\u000A        __declspec(align(64)) sycl::buffer<DataType, 1> *bank_buffer =\u000A            new sycl::buffer<DataType, 1>(out_matrix[i], kData_range);\u000A        bank_bufs.push_back(bank_buffer);\u000A      });\u000A\u000A      // Consumer\u000A      sycl::event consumer_events[BANKS];\u000A      fpga_tools::UnrolledLoop<BANKS>([&](auto i) {\u000A        consumer_events[i] = q.submit([&](sycl::handler &h) {\u000A          sycl::accessor bank_acc(bank_bufs[i][0], h, sycl::read_write,\u000A                                  sycl::ext::oneapi::accessor_property_list{\u000A                                      sycl::ext::oneapi::no_alias,\u000A                                      sycl::ext::intel::buffer_location<i>});\u000A          h.single_task<ConsumerKernel<i>>([=]() {\u000A            for (int data_idx = 0; data_idx < kDataCount; data_idx++) {\u000A              bank_acc[data_idx] = data_idx;\u000A            }\u000A          });\u000A        });\u000A      });\u000A\u000A      q.wait();\u000A\u000A      printf(\"\\nAll kernels finished\\n\");\u000A\u000A      // free all the buffers (so data gets moved to the host)\u000A      for (int i = 0; i < BANKS; i++) {\u000A        delete bank_bufs[i];\u000A      }\u000A\u000A      // getting throughput number\u000A      uint64_t start = 0;\u000A      uint64_t end = 0;\u000A      for (int i = 0; i < BANKS; ++i) {\u000A        uint64_t curr_start = (consumer_events[i].\u000A                   get_profiling_info<sycl::info::event_profiling::command_start>());\u000A        uint64_t curr_end = (consumer_events[i].\u000A                 get_profiling_info<sycl::info::event_profiling::command_end>());\u000A        double curr_duration = static_cast<double>(curr_end - curr_start) / NSEC_IN_SEC;\u000A        std::cout << \"ConsumerKernel=\" << i << \" : start=\" << curr_start << \" end=\" << curr_end \u000A                     << \" duration=\" << curr_duration  << \" sec\" <<std::endl;\u000A        if (i != 0)\u000A          start = min(curr_start, start);\u000A        else\u000A          start = curr_start;\u000A        end = max(curr_end, end);\u000A      }\u000A\u000A      double duration = static_cast<double>(end - start) / NSEC_IN_SEC;\u000A      std::cout << \"\\nkernels execution time: \" << duration << \" sec\"\u000A                << std::endl;\u000A      std::cout << \"\\nWrite ops per second: \"\u000A                << (kDataCount * BANKS) / duration \u000A                << std::endl;\u000A      std::cout << \"\\nWrite ops per bank per second: \"\u000A                << ((kDataCount * BANKS) / duration) / BANKS\u000A                << std::endl;\u000A      printf(\"\\n\");\u000A    }\u000A\u000A    // check for correctness\u000A    bool passed = true;\u000A    for (int bank = 0; bank < BANKS; bank++) {\u000A      for (int data_i = 0; data_i < kDataCount; data_i++) {\u000A        if (out_matrix[bank][data_i] != (DataType)data_i) {\u000A          passed = false;\u000A          std::cout << \"Mismatch: Bank\" << bank << \"[\" << data_i\u000A                    << \"] = \" << out_matrix[bank][data_i] << std::endl;\u000A        }\u000A      }\u000A    }\u000A\u000A    for (int j = 0; j < BANKS; j++) {\u000A      free(out_matrix[j]);\u000A    }\u000A\u000A    std::cout << (passed ? \"PASSED\" : \"FAILED\") << std::endl;\u000A    return passed ? EXIT_SUCCESS : EXIT_FAILURE;\u000A\u000A  } catch (sycl::exception const &e) {\u000A    // Catches exceptions in the host code\u000A    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\u000A    std::terminate();\u000A  }\u000A}\u000A"}, {"path":"/ihome/ageorge/opl1/Documents/k_mers/kmer_testing/src/metaprogramming_utils.hpp", "name":"metaprogramming_utils.hpp", "has_active_debug_locs":false, "absName":"/ihome/ageorge/opl1/Documents/k_mers/kmer_testing/src/metaprogramming_utils.hpp", "content":"#ifndef __METAPROGRAMMING_UTILS_HPP__\u000A#define __METAPROGRAMMING_UTILS_HPP__\u000A\u000A#include <type_traits>\u000A\u000Anamespace fpga_tools {\u000A\u000A//\u000A// The code below creates the constexprs 'make_integer_range'\u000A// and 'make_index_range' these are akin to 'std::make_integer_sequence'\u000A// and 'std::make_index_sequence', respectively.\u000A// However they allow you to specificy a range and can either increment\u000A// or decrement, rather than a strict increasing sequence\u000A//\u000Atemplate <typename T, typename, T begin, bool increase>\u000Astruct integer_range_impl;\u000A\u000A// incrementing case\u000Atemplate <typename T, T... N, T begin>\u000Astruct integer_range_impl<T, std::integer_sequence<T, N...>, begin, true> {\u000A  using type = std::integer_sequence<T, N + begin...>;\u000A};\u000A\u000A// decrementing case\u000Atemplate <typename T, T... N, T begin>\u000Astruct integer_range_impl<T, std::integer_sequence<T, N...>, begin, false> {\u000A  using type = std::integer_sequence<T, begin - N...>;\u000A};\u000A\u000A// integer_range\u000Atemplate <typename T, T begin, T end>\u000Ausing integer_range = typename integer_range_impl<\u000A    T, std::make_integer_sequence<T, (begin < end) ? end - begin : begin - end>,\u000A    begin, (begin < end)>::type;\u000A\u000A//\u000A// make_integer_range\u000A//\u000A// USAGE:\u000A//    make_integer_range<int,1,10>{} ==> 1,2,...,9\u000A//    make_integer_range<int,10,1>{} ==> 10,9,...,2\u000A//\u000Atemplate <class T, T begin, T end>\u000Ausing make_integer_range = integer_range<T, begin, end>;\u000A\u000A//\u000A// make_index_range\u000A//\u000A// USAGE:\u000A//    make_index_range<1,10>{} ==> 1,2,...,9\u000A//    make_index_range<10,1>{} ==> 10,9,...,2\u000A//\u000Atemplate <std::size_t begin, std::size_t end>\u000Ausing make_index_range = integer_range<std::size_t, begin, end>;\u000A\u000A//\u000A// The code below creates the constexprs 'make_integer_pow2_sequence'\u000A// and 'make_index_pow2_sequence'. These generate the sequence\u000A// 2^0, 2^1, 2^2, ... , 2^(N-1) = 1,2,4,...,2^(N-1)\u000A//\u000Atemplate <typename T, typename>\u000Astruct integer_pow2_sequence_impl;\u000A\u000Atemplate <typename T, T... Pows>\u000Astruct integer_pow2_sequence_impl<T, std::integer_sequence<T, Pows...>> {\u000A  using type = std::integer_sequence<T, (T(1) << Pows)...>;\u000A};\u000A\u000A// integer_pow2_sequence\u000Atemplate <typename T, T N>\u000Ausing integer_pow2_sequence =\u000A    typename integer_pow2_sequence_impl<T,\u000A                                        std::make_integer_sequence<T, N>>::type;\u000A\u000A//\u000A// make_integer_pow2_sequence\u000A//\u000A// USAGE:\u000A//    make_integer_pow2_sequence<int,5>{} ==> 1,2,4,8,16\u000A//\u000Atemplate <class T, T N>\u000Ausing make_integer_pow2_sequence = integer_pow2_sequence<T, N>;\u000A\u000A//\u000A// make_index_pow2_sequence\u000A//\u000A// USAGE:\u000A//    make_index_pow2_sequence<5>{} ==> 1,2,4,8,16\u000A//\u000Atemplate <std::size_t N>\u000Ausing make_index_pow2_sequence = integer_pow2_sequence<std::size_t, N>;\u000A\u000A//\u000A// Checks for existence of subscript operator\u000A//\u000Anamespace detail {\u000Atemplate <typename... >\u000Ausing void_t = void;\u000A\u000Atemplate<class T, typename = void>\u000Astruct has_subscript_impl : std::false_type { };\u000A\u000Atemplate<typename T>\u000Astruct has_subscript_impl<T, void_t<decltype(std::declval<T>()[1])>> \u000A  : std::true_type { };\u000A}  // namespace detail\u000A\u000Atemplate <typename T>\u000Astruct has_subscript {\u000A  static constexpr bool value =\u000A    std::is_same_v<typename detail::has_subscript_impl<T>::type, std::true_type>;\u000A};\u000A\u000Atemplate <typename T>\u000Ainline constexpr bool has_subscript_v = has_subscript<T>::value;\u000A\u000A//\u000A// checks if a type is any instance of SYCL pipe\u000A//\u000Anamespace detail {\u000A\u000Atemplate<typename T>\u000Astruct is_sycl_pipe_impl : std::false_type {};\u000A\u000Atemplate<typename Id, typename T, std::size_t N>\u000Astruct is_sycl_pipe_impl<sycl::ext::intel::pipe<Id, T, N>> : std::true_type {};\u000A\u000A}  // namespace detail\u000A\u000Atemplate <typename T>\u000Astruct is_sycl_pipe {\u000A  static constexpr bool value = detail::is_sycl_pipe_impl<T>{};\u000A};\u000A\u000Atemplate <typename T>\u000Ainline constexpr bool is_sycl_pipe_v = is_sycl_pipe<T>::value;\u000A\u000A} // namespace fpga_tools\u000A\u000A#endif  /* __METAPROGRAMMING_UTILS_HPP__ */"}, {"path":"/ihome/ageorge/opl1/Documents/k_mers/kmer_testing/src/pipe_utils.hpp", "name":"pipe_utils.hpp", "has_active_debug_locs":false, "absName":"/ihome/ageorge/opl1/Documents/k_mers/kmer_testing/src/pipe_utils.hpp", "content":"//==============================================================\u000A// Copyright Intel Corporation\u000A//\u000A// SPDX-License-Identifier: MIT\u000A// =============================================================\u000A#ifndef __PIPE_UTILS_HPP__\u000A#define __PIPE_UTILS_HPP__\u000A\u000A#include <sycl/sycl.hpp>\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A#include <utility>\u000A\u000A/*\u000A\u000AThis header defines the following utilities for use with pipes in SYCL FPGA\u000Adesigns.\u000A\u000A1. PipeArray\u000A\u000A      Create a collection of pipes that can be indexed like an array.\u000A\u000A      template <class Id,          // identifier for the pipe array\u000A                typename BaseTy,   // type to write/read for each pipe\u000A                size_t min_depth,  // minimum capacity of each pipe\u000A                size_t... dims     // depth of each dimension in the array\u000A                                   // any number of dimensions are supported\u000A                >\u000A      struct PipeArray\u000A\u000A      Example usage:\u000A    \u000A      class PipeArrayId;\u000A      constexpr int min_depth = 0;\u000A      constexpr int num_pipes = 4;\u000A      using MyPipeArray = PipeArray<PipeArrayId, int, min_depth, num_pipes>;\u000A      ...\u000A      constexpr int pipe_idx = 1;\u000A      MyPipeArray::PipeAt<pipe_idx>::read(); \u000A\u000A2. PipeDuplicator\u000A\u000A      Fan-out a single pipe write to multiple pipe instances,\u000A      each of which will receive the same data.\u000A      A blocking write will perform a blocking write to each pipe.\u000A      A non-blocking write will perform a non-blocking write to each pipe,\u000A      and set success to true only if ALL writes were successful.\u000A\u000A      Note that the special case of 0 pipe instances is supported, which can \u000A      be useful as a stub for writes to pipes that are not needed in your particular \u000A      design.\u000A\u000A      template <class Id,          // name of this PipeDuplicator\u000A                typename T,        // data type to transfer\u000A                typename... Pipes  // all pipes to send duplicated writes to\u000A                >\u000A      struct PipeDuplicator\u000A\u000A      Example usage:\u000A\u000A      class PipeID1;\u000A      class PipeID2;\u000A      using MyPipe1 = sycl::ext::intel::pipe<PipeID1, int>;\u000A      using MyPipe2 = sycl::ext::intel::pipe<PipeID2, int>;\u000A\u000A      class PipeDuplicatorID;\u000A      using MyPipeDuplicator = PipeDuplicator<PipeDuplicatorID, int, MyPipe1, MyPipe2>;\u000A      ...\u000A      MyPipeDuplicator::write(1); // write the value 1 to both MyPipe1 and MyPipe2\u000A\u000A*/\u000A\u000A// =============================================================\u000A// Internal Helper Functions/Structs\u000A// =============================================================\u000A\u000Anamespace fpga_tools {\u000Anamespace detail {\u000A\u000A// Templated classes for verifying dimensions when accessing elements in the\u000A// pipe array.\u000Atemplate <size_t dim1, size_t... dims>\u000Astruct VerifierDimLayer {\u000A  template <size_t idx1, size_t... idxs>\u000A  struct VerifierIdxLayer {\u000A    static constexpr bool IsValid() {\u000A      return idx1 < dim1 &&\u000A             (VerifierDimLayer<dims...>::template VerifierIdxLayer<\u000A                 idxs...>::IsValid());\u000A    }\u000A  };\u000A};\u000Atemplate <size_t dim>\u000Astruct VerifierDimLayer<dim> {\u000A  template <size_t idx>\u000A  struct VerifierIdxLayer {\u000A    static constexpr bool IsValid() { return idx < dim; }\u000A  };\u000A};\u000A\u000A// Templated classes to perform 'currying' write to all pipes in the array\u000A// Primary template, dummy\u000Atemplate <template <std::size_t...> class WriteFunc, typename BaseTy,\u000A          typename PartialSequence, typename... RemainingSequences>\u000Astruct write_currying {};\u000A// Induction case\u000Atemplate <template <std::size_t...> class WriteFunc, typename BaseTy,\u000A          std::size_t... I, std::size_t... J, typename... RemainingSequences>\u000Astruct write_currying<WriteFunc, BaseTy, std::index_sequence<I...>,\u000A                      std::index_sequence<J...>, RemainingSequences...> {\u000A  void operator()(const BaseTy &data, bool &success) const {\u000A    (write_currying<WriteFunc, BaseTy, std::index_sequence<I..., J>,\u000A                    RemainingSequences...>()(data, success),\u000A     ...);\u000A  }\u000A};\u000A// Base case\u000Atemplate <template <std::size_t...> class WriteFunc, typename BaseTy,\u000A          std::size_t... I>\u000Astruct write_currying<WriteFunc, BaseTy, std::index_sequence<I...>> {\u000A  void operator()(const BaseTy &data, bool &success) const {\u000A    WriteFunc<I...>()(data, success);\u000A  }\u000A};\u000A\u000A}  // namespace detail\u000A\u000A// =============================================================\u000A// PipeArray\u000A// =============================================================\u000A\u000Atemplate <class Id,          // identifier for the pipe array\u000A          typename BaseTy,   // type to write/read for each pipe\u000A          size_t min_depth,  // minimum capacity of each pipe\u000A          size_t... dims     // depth of each dimension in the array\u000A                             // any number of dimensions are supported\u000A          >\u000Astruct PipeArray {\u000A  PipeArray() = delete;  // ensure we cannot create an instance\u000A\u000A  template <size_t... idxs>\u000A  struct StructId;  // the ID of each pipe in the array\u000A\u000A  // VerifyIndices checks that we only access pipe indicies that are in range\u000A  template <size_t... idxs>\u000A  struct VerifyIndices {\u000A    static_assert(sizeof...(idxs) == sizeof...(dims),\u000A                  \"Indexing into a PipeArray requires as many indices as \"\u000A                  \"dimensions of the PipeArray.\");\u000A    static_assert(fpga_tools::detail::VerifierDimLayer<dims...>::template\u000A                  VerifierIdxLayer<idxs...>::IsValid(),\u000A                  \"Index out of bounds\");\u000A    using VerifiedPipe =\u000A        sycl::ext::intel::pipe<StructId<idxs...>, BaseTy, min_depth>;\u000A  };\u000A\u000A  // helpers for accessing the dimensions of the pipe array\u000A  // usage:\u000A  //  MyPipeArray::GetNumDims() - number of dimensions in this pipe array\u000A  //  MyPipeArray::GetDimSize<3>() - size of dimension 3 in this pipe array\u000A  static constexpr size_t GetNumDims() { return (sizeof...(dims)); }\u000A  template <int dim_num>\u000A  static constexpr size_t GetDimSize() {\u000A    return std::get<dim_num>(dims...);\u000A  }\u000A\u000A  // PipeAt<idxs...> is used to reference a pipe at a particular index\u000A  template <size_t... idxs>\u000A  using PipeAt = typename VerifyIndices<idxs...>::VerifiedPipe;\u000A\u000A  // functor to impllement blocking write to all pipes in the array\u000A  template <std::size_t... I>\u000A  struct BlockingWriteFunc {\u000A    void operator()(const BaseTy &data, bool &success) const {\u000A      PipeAt<I...>::write(data);\u000A    }\u000A  };\u000A  // functor to impllement non-blocking write to all pipes in the array\u000A  template <std::size_t... I>\u000A  struct NonBlockingWriteFunc {\u000A    void operator()(const BaseTy &data, bool &success) const {\u000A      PipeAt<I...>::write(data, success);\u000A    }\u000A  };\u000A  // helper function for implementing write() call to all pipes in the array\u000A  template <template <std::size_t...> class WriteFunc,\u000A            typename... IndexSequences>\u000A  static void write_currying_helper(const BaseTy &data, bool &success,\u000A                                    IndexSequences...) {\u000A    fpga_tools::detail::write_currying<WriteFunc, BaseTy,\u000A                   std::index_sequence<>, IndexSequences...>()(data, success);\u000A  }\u000A\u000A  // blocking write\u000A  // write the same data to all pipes in the array using blocking writes\u000A  static void write(const BaseTy &data) {\u000A    bool success;  // temporary variable, ignored in BlockingWriteFunc\u000A    write_currying_helper<BlockingWriteFunc>(\u000A        data, success, std::make_index_sequence<dims>()...);\u000A  }\u000A\u000A  // non-blocking write\u000A  // write the same data to all pipes in the array using non-blocking writes\u000A  static void write(const BaseTy &data, bool &success) {\u000A    write_currying_helper<NonBlockingWriteFunc>(\u000A        data, success, std::make_index_sequence<dims>()...);\u000A  }\u000A\u000A};  // end of struct PipeArray\u000A\u000A// =============================================================\u000A// PipeDuplicator\u000A// =============================================================\u000A\u000A// Connect a kernel that writes to a single pipe to multiple pipe instances,\u000A// each of which will receive the same data.\u000A// A blocking write will perform a blocking write to each pipe.  A non-blocking\u000A// write will perform a non-blocking write to each pipe, and set success to\u000A// true only if ALL writes were successful.\u000A\u000A// primary template, dummy\u000Atemplate <class Id,          // name of this PipeDuplicator\u000A          typename T,        // data type to transfer\u000A          typename... Pipes  // all pipes to send duplicated writes to\u000A          >\u000Astruct PipeDuplicator {};\u000A\u000A// recursive case, write to each pipe\u000Atemplate <class Id,                   // name of this PipeDuplicator\u000A          typename T,                 // data type to transfer\u000A          typename FirstPipe,         // at least one output pipe\u000A          typename... RemainingPipes  // additional copies of the output pipe\u000A          >\u000Astruct PipeDuplicator<Id, T, FirstPipe, RemainingPipes...> {\u000A  PipeDuplicator() = delete;  // ensure we cannot create an instance\u000A\u000A  // Non-blocking write\u000A  static void write(const T &data, bool &success) {\u000A    bool local_success;\u000A    FirstPipe::write(data, local_success);\u000A    success = local_success;\u000A    PipeDuplicator<Id, T, RemainingPipes...>::write(data, local_success);\u000A    success &= local_success;\u000A  }\u000A\u000A  // Blocking write\u000A  static void write(const T &data) {\u000A    FirstPipe::write(data);\u000A    PipeDuplicator<Id, T, RemainingPipes...>::write(data);\u000A  }\u000A};\u000A\u000A// base case for recursion, no pipes to write to\u000A// also useful as a 'null' pipe, writes don't do anything\u000Atemplate <class Id,   // name of this PipeDuplicator\u000A          typename T  // data type to transfer\u000A          >\u000Astruct PipeDuplicator<Id, T> {\u000A  PipeDuplicator() = delete;  // ensure we cannot create an instance\u000A\u000A  // Non-blocking write\u000A  static void write(const T & /*data*/, bool &success) { success = true; }\u000A\u000A  // Blocking write\u000A  static void write(const T & /*data*/) {\u000A    // do nothing\u000A  }\u000A};\u000A\u000A} // namespace fpga_tools\u000A\u000A#endif /* __PIPE_UTILS_HPP__ */"}, {"path":"/opt/intel/oneapi/tbb/2021.10.0/include/tbb/tbb.h", "name":"tbb.h", "has_active_debug_locs":false, "absName":"/opt/intel/oneapi/tbb/2021.10.0/include/tbb/tbb.h", "content":"/*\u000A    Copyright (c) 2005-2021 Intel Corporation\u000A\u000A    Licensed under the Apache License, Version 2.0 (the \"License\");\u000A    you may not use this file except in compliance with the License.\u000A    You may obtain a copy of the License at\u000A\u000A        http://www.apache.org/licenses/LICENSE-2.0\u000A\u000A    Unless required by applicable law or agreed to in writing, software\u000A    distributed under the License is distributed on an \"AS IS\" BASIS,\u000A    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\u000A    See the License for the specific language governing permissions and\u000A    limitations under the License.\u000A*/\u000A\u000A#include \"../oneapi/tbb.h\"\u000A"}, {"path":"/ihome/ageorge/opl1/Documents/k_mers/kmer_testing/src/unrolled_loop.hpp", "name":"unrolled_loop.hpp", "has_active_debug_locs":false, "absName":"/ihome/ageorge/opl1/Documents/k_mers/kmer_testing/src/unrolled_loop.hpp", "content":"#ifndef __UNROLLEDLOOP_HPP__\u000A#define __UNROLLEDLOOP_HPP__\u000A\u000A#include <type_traits>\u000A#include <utility>\u000A\u000A#include \"metaprogramming_utils.hpp\"\u000A\u000Anamespace fpga_tools {\u000A///////////////////////////////////////////////////////////////////////////////\u000A//\u000A// Example usage for UnrolledLoop constexpr:\u000A//\u000A// Base\u000A//    UnrolledLoop(std::integer_sequence<int,5,2,7,8>{},[&](auto i) {\u000A//      /* i = 5,2,7,8 */\u000A//    });\u000A//\u000A// Case A\u000A//    UnrolledLoop<10>([&](auto i) {\u000A//      /* i = 0,1,...,9 */\u000A//    });\u000A//\u000A// Case B\u000A//    UnrolledLoop<10>([&](auto i) {\u000A//      /* i = 0,1,...,9 */\u000A//    });\u000A//\u000A// Case C\u000A//    UnrolledLoop<char, 1, 10>([&](auto i) {\u000A//      /* i = 1,2,...,9 */\u000A//    });\u000A//    UnrolledLoop<char, 10, 1>([&](auto i) {\u000A//      /* i = 10,9,...,2 */\u000A//    });\u000A//\u000A// Case D\u000A//    UnrolledLoop<1, 10>([&](auto i) {\u000A//      /* i = 1,2,...,9 */\u000A//    });\u000A//    UnrolledLoop<10, 1>([&](auto i) {\u000A//      /* i = 10,9,...,2 */\u000A//    });\u000A//\u000A///////////////////////////////////////////////////////////////////////////////\u000A\u000A//\u000A// Base implementation\u000A// Templated on:\u000A//    ItType    - the type of the iterator (size_t, int, char, ...)\u000A//    ItType... - the indices to iterate on\u000A//    F         - the function to run for each index (i.e. the lambda)\u000A//\u000Atemplate <class ItType, ItType... inds, class F>\u000Aconstexpr void UnrolledLoop(std::integer_sequence<ItType, inds...>, F&& f) {\u000A  (f(std::integral_constant<ItType, inds>{}), ...);\u000A}\u000A\u000A//\u000A// Convience implementation (A)\u000A// performs UnrolledLoop in range [0,n) with iterator of type ItType\u000A//\u000Atemplate <class ItType, ItType n, class F>\u000Aconstexpr void UnrolledLoop(F&& f) {\u000A  UnrolledLoop(std::make_integer_sequence<ItType, n>{}, std::forward<F>(f));\u000A}\u000A\u000A//\u000A// Convenience implementation (B)\u000A// performs UnrolledLoop in range [0,n) with an iterator of type std::size_t\u000A//\u000Atemplate <std::size_t n, class F>\u000Aconstexpr void UnrolledLoop(F&& f) {\u000A  UnrolledLoop(std::make_index_sequence<n>{}, std::forward<F>(f));\u000A}\u000A\u000A//\u000A// Convenience implementation (C)\u000A// performs UnrolledLoop from start...end with an iterator of type ItType\u000A// NOTE:  start is INCLUSIVE, end is EXCLUSIVE\u000A// NOTE:  if start<=end, sequence is start,start+1,...,end-1\u000A//        if end<=start, sequence is start,start-1,...,end+1\u000A//\u000Atemplate <class ItType, ItType start, ItType end, class F>\u000Aconstexpr void UnrolledLoop(F&& f) {\u000A  UnrolledLoop(make_integer_range<ItType, start, end>{}, std::forward<F>(f));\u000A}\u000A\u000A//\u000A// Convenience implementation (D)\u000A// performs UnrolledLoop from start...end with an iterator of type size_t\u000A// NOTE:  start is INCLUSIVE, end is EXCLUSIVE\u000A// NOTE:  if start<=end, sequence is start,start+1,...,end-1\u000A//        if end<=start, sequence is start,start-1,...,end+1\u000A//\u000Atemplate <std::size_t start, std::size_t end, class F>\u000Aconstexpr void UnrolledLoop(F&& f) {\u000A  UnrolledLoop(make_index_range<start, end>{}, std::forward<F>(f));\u000A}\u000A\u000A\u000A}  // namespace fpga_tools\u000A\u000A#endif /* __UNROLLEDLOOP_HPP__ */"}]